<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Tropical Ocean</title>
    
    <!-- Tailwind CSS for styling UI elements -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- p5.js for the main animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
      body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: 'Inter', sans-serif; }
      .project-content { width: 100%; aspect-ratio: 16 / 9; position: relative; background-color: #000; overflow: hidden; border-radius: 0.5rem; }
      #defaultCanvas0 { position: absolute; top: 0; left: 0; width: 100% !important; height: 100% !important; z-index: 1; }
    </style>
  </head>
  <body>
    <div class="project-content">
        <!-- p5.js canvas will be placed here -->
    </div>

    <script>
      // =================================================================
      //  OCEAN ANIMATION SCRIPT
      // =================================================================
      let p5_instance;

      const sketch = (p) => {
          let time = 0;
          let fish = [];
          
          let waterColor1, waterColor2, sandColor;

          // --- Fish class (manta rays) ---
          class Fish {
              constructor() {
                  this.x = p.random(p.width);
                  this.y = p.random(p.height);
                  this.noiseOffsetX = p.random(1000);
                  this.noiseOffsetY = p.random(1000);
                  this.size = p.random(40, 60);
                  this.vx = 0;
                  this.vy = 0;
                  this.flapOffset = p.random(p.TWO_PI);

                  this.basePattern = [
                      [0,0,1,0,0,0,1,0,0],
                      [0,1,1,1,1,1,1,1,0],
                      [1,1,1,1,1,1,1,1,1],
                      [0,1,1,1,1,1,1,1,0],
                      [0,0,1,1,1,1,1,0,0],
                      [0,0,0,0,1,0,0,0,0],
                      [0,0,0,0,1,0,0,0,0],
                      [0,0,0,0,1,0,0,0,0],
                  ];
                  this.patternCenterX = p.floor(this.basePattern[0].length / 2);
                  this.patternCenterY = p.floor(this.basePattern.length / 2);
              }
              rotatePattern(angle) {
                  const rotated = new Set();
                  const cosA = p.cos(angle), sinA = p.sin(angle);
                  for (let y=0; y<this.basePattern.length; y++) {
                      for (let x=0; x<this.basePattern[y].length; x++) {
                          if (this.basePattern[y][x]===1) {
                              const relX = x - this.patternCenterX;
                              const relY = y - this.patternCenterY;
                              const rotX = p.round(relX*cosA - relY*sinA);
                              const rotY = p.round(relX*sinA + relY*cosA);
                              rotated.add(`${rotX},${rotY}`);
                          }
                      }
                  }
                  return Array.from(rotated).map(s => s.split(",").map(Number));
              }
              update() {
                  let angle = p.noise(this.noiseOffsetX + time*0.1, this.noiseOffsetY + time*0.1) * p.TWO_PI * 2;
                  const speed = p.map(this.size, 40, 60, 2.5, 1.5);
                  this.vx = p.cos(angle) * speed;
                  this.vy = p.sin(angle) * speed;
                  this.x += this.vx;
                  this.y += this.vy;
                  const pad = this.size*2;
                  if (this.x < -pad) this.x = p.width + pad;
                  if (this.x > p.width + pad) this.x = -pad;
                  if (this.y < -pad) this.y = p.height + pad;
                  if (this.y > p.height + pad) this.y = -pad;
              }
              display() {
                  p.noStroke();
                  const gridX = p.round(this.x/20)*20;
                  const gridY = p.round(this.y/20)*20;
                  const mag = p.sqrt(this.vx*this.vx + this.vy*this.vy);
                  if (mag===0) return;
                  const ux = this.vx/mag, uy = this.vy/mag;
                  const ang = p.atan2(this.vy,this.vx)+p.PI/2;
                  const coords = this.rotatePattern(ang);
                  const flap = p.sin(time*5 + this.flapOffset);
                  for (const c of coords) {
                      let px = gridX + c[0]*20;
                      let py = gridY + c[1]*20;
                      let dp = (c[0]*20)*ux + (c[1]*20)*uy;
                      let diff = p.map(dp, -100,100,-1,1,true);
                      let noiseCol = p.noise(px*0.005,py*0.005,time*0.1);
                      let baseC = p.lerpColor(waterColor1, waterColor2, noiseCol);
                      let finalC;
                      if (diff>0) {
                          let dark = p.color(0,40,60,200);
                          finalC = p.lerpColor(baseC, dark, diff * p.map(flap,-1,1,0.4,1));
                      } else {
                          let light = p.color(255,255,200,150);
                          finalC = p.lerpColor(baseC, light, -diff*0.5);
                          let turb = -diff * p.map(flap,-1,1,0,1)*6;
                          px += p.random(-turb,turb);
                          py += p.random(-turb,turb);
                      }
                      let d2 = p.sqrt((c[0]*20)**2 + (c[1]*20)**2);
                      let darkF = p.map(d2,0,80,0.4,0,true);
                      let cenC = p.lerpColor(finalC, p.color(0,40,60,200), darkF);
                      p.fill(cenC);
                      p.rect(p.round(px/20)*20,p.round(py/20)*20,20,20);
                  }
              }
          }

          p.setup = () => {
              let container = document.querySelector('.project-content');
              p.createCanvas(container.clientWidth, container.clientHeight).parent(container);
              p.noStroke();
              
              waterColor1 = p.color(32,178,170,150);
              waterColor2 = p.color(0,255,255,150);
              sandColor   = p.color(194,178,128);
              
              for (let i=0;i<15;i++) fish.push(new Fish());
          };

          p.draw = () => {
              p.background(sandColor);
              // water base
              for (let x=0;x<p.width; x+=20) {
                  for (let y=0;y<p.height; y+=20) {
                      let wn = p.noise(x*0.005,y*0.005,time*0.1);
                      p.fill(p.lerpColor(waterColor1, waterColor2, wn));
                      p.rect(x,y,20,20);
                  }
              }
              // fish
              fish.forEach(f => { f.update(); f.display(); });
              // caustics & clouds
              for (let x=0;x<p.width; x+=20) {
                  for (let y=0;y<p.height; y+=20) {
                      let cn = p.noise(x*0.02+time*0.3, y*0.02+time*0.3);
                      if (cn>0.65) { p.fill(255,255,200,cn*80); p.rect(x,y,20,20); }
                      if (x%40===0 && y%40===0) {
                          let cl = p.noise(x*0.001+time*0.02,y*0.002+time*0.02);
                          if (cl>0.5) { p.fill(255,255,255,(cl-0.5)*60); p.rect(x,y,40,40); }
                      }
                  }
              }
              
              time += 0.02;
          };

          p.windowResized = () => {
              let container = document.querySelector('.project-content');
              p.resizeCanvas(container.clientWidth, container.clientHeight);
          };
      };

      // Initialize the p5.js sketch
      p5_instance = new p5(sketch);
    </script>
  </body>
</html>
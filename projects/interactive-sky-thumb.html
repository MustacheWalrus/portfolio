<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Sky Thumbnail</title>
    
    <!-- p5.js for the main animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
        font-family: 'Inter', sans-serif;
      }
      canvas {
        display: block;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <script>
      // =================================================================
      //  SIMPLIFIED THUMBNAIL SCRIPT
      // =================================================================

      // --- p5.js Animation Variables ---
      let farClouds = [], nearClouds = [], flock = [], stars = [];
      let cycleDuration = 3600, time = 0, colors;

      // --- p5.js Setup Function ---
      function setup() {
        createCanvas(windowWidth, windowHeight);
        
        colors = {
            dawn: { top: color(24, 58, 114), bottom: color(240, 150, 114) },
            day: { top: color(135, 206, 250), bottom: color(240, 248, 255) },
            dusk: { top: color(24, 58, 114), bottom: color(218, 93, 76) },
            night: { top: color(1, 2, 20), bottom: color(14, 28, 64) }
        };

        // Reduced number of objects for performance
        for (let i = 0; i < 10; i++) farClouds.push(new Cloud(random(width), random(height * 0.6), random(50, 100), 0.2));
        for (let i = 0; i < 5; i++) nearClouds.push(new Cloud(random(width), random(height * 0.7), random(80, 180), 0.5));
        for (let i = 0; i < 50; i++) flock.push(new Boid());
        for (let i = 0; i < 150; i++) stars.push(createVector(random(width), random(height)));
      }

      // --- p5.js Draw Function ---
      function draw() {
        time = (frameCount % cycleDuration) / cycleDuration;
        let sky = getSkyColors(time);
        
        for (let i = 0; i < height; i++) {
          let inter = map(i, 0, height, 0, 1);
          let c = lerpColor(sky.top, sky.bottom, inter);
          stroke(c);
          line(0, i, width, i);
        }

        let lightLevel = getLightLevel(time);
        drawStars(1 - lightLevel**2);
        drawSunAndMoon(time);

        let cloudColor = lerpColor(color(80, 80, 100, 180), color(255, 255, 255, 210), lightLevel);
        farClouds.forEach(c => { c.move(); c.display(cloudColor); });

        let boidColor = lerpColor(color(180, 180, 200, 150), color(40, 40, 40, 200), lightLevel);
        flock.forEach(boid => {
          boid.edges();
          boid.flock(flock); // Simplified flocking without avoidance
          boid.update();
          boid.show(boidColor);
        });
        
        nearClouds.forEach(c => { c.move(); c.display(cloudColor); });
        
        // --- Draw Overlay Text ---
        textAlign(CENTER, CENTER);
        fill(255, 255, 255, 200);
        noStroke();
        textSize(24);
        textStyle(BOLD);
        text("Click to Explore", width / 2, height / 2);
      }

      // --- Boid Class (Simplified) ---
      class Boid {
        constructor() {
          this.position = createVector(random(width), random(height));
          this.velocity = p5.Vector.random2D();
          this.velocity.setMag(random(2, 4));
          this.acceleration = createVector();
          this.maxForce = 0.3; 
          this.maxSpeed = 5;
        }

        // Simplified flocking without obstacle avoidance
        flock(boids) {
          let alignment = this.align(boids);
          let cohesion = this.cohesion(boids);
          let separation = this.separation(boids);

          separation.mult(2.0); 
          alignment.mult(1.0);
          cohesion.mult(1.0);

          this.acceleration.add(separation);
          this.acceleration.add(alignment);
          this.acceleration.add(cohesion);
        }

        edges() { if (this.position.x > width) this.position.x = 0; else if (this.position.x < 0) this.position.x = width; if (this.position.y > height) this.position.y = 0; else if (this.position.y < 0) this.position.y = height; }
        align(boids) { let perceptionRadius = 50; let steering = createVector(); let total = 0; for (let other of boids) { let d = dist(this.position.x, this.position.y, other.position.x, other.position.y); if (other != this && d < perceptionRadius) { steering.add(other.velocity); total++; } } if (total > 0) { steering.div(total); steering.setMag(this.maxSpeed); steering.sub(this.velocity); steering.limit(this.maxForce); } return steering; }
        separation(boids) { let perceptionRadius = 40; let steering = createVector(); let total = 0; for (let other of boids) { let d = dist(this.position.x, this.position.y, other.position.x, other.position.y); if (other != this && d < perceptionRadius) { let diff = p5.Vector.sub(this.position, other.position); diff.div(d * d); steering.add(diff); total++; } } if (total > 0) { steering.div(total); steering.setMag(this.maxSpeed); steering.sub(this.velocity); steering.limit(this.maxForce); } return steering; }
        cohesion(boids) { let perceptionRadius = 60; let steering = createVector(); let total = 0; for (let other of boids) { let d = dist(this.position.x, this.position.y, other.position.x, other.position.y); if (other != this && d < perceptionRadius) { steering.add(other.position); total++; } } if (total > 0) { steering.div(total); steering.sub(this.position); steering.setMag(this.maxSpeed); steering.sub(this.velocity); steering.limit(this.maxForce); } return steering; }
        update() { this.position.add(this.velocity); this.velocity.add(this.acceleration); this.velocity.limit(this.maxSpeed); this.acceleration.mult(0); }
        show(c) { let theta = this.velocity.heading() + PI / 2; fill(c); stroke(lerpColor(c, color(0), 0.5)); strokeWeight(1); push(); translate(this.position.x, this.position.y); rotate(theta); beginShape(); vertex(0, -6); vertex(-3, 6); vertex(3, 6); endShape(CLOSE); pop(); }
      }

      // --- All other helper functions for p5.js animation ---
      function getSkyColors(t) { if (t < 0.25) { return { top: lerpColor(colors.night.top, colors.dawn.top, map(t, 0, 0.25, 0, 1)), bottom: lerpColor(colors.night.bottom, colors.dawn.bottom, map(t, 0, 0.25, 0, 1)) }; } else if (t < 0.5) { return { top: lerpColor(colors.dawn.top, colors.day.top, map(t, 0.25, 0.5, 0, 1)), bottom: lerpColor(colors.dawn.bottom, colors.day.bottom, map(t, 0.25, 0.5, 0, 1)) }; } else if (t < 0.75) { return { top: lerpColor(colors.day.top, colors.dusk.top, map(t, 0.5, 0.75, 0, 1)), bottom: lerpColor(colors.day.bottom, colors.dusk.bottom, map(t, 0.5, 0.75, 0, 1)) }; } else { return { top: lerpColor(colors.dusk.top, colors.night.top, map(t, 0.75, 1, 0, 1)), bottom: lerpColor(colors.dusk.bottom, colors.night.bottom, map(t, 0.75, 1, 0, 1)) }; } }
      function getLightLevel(t) { let angle = map(t, 0, 1, 0, TWO_PI); return (-cos(angle) + 1) / 2; }
      function drawSunAndMoon(t) { let sunAngle = map(t, 0.25, 0.75, PI, 0); let sunX = width / 2 + (width/2 + 40) * cos(sunAngle); let sunY = height * 0.8 - (height * 0.7) * sin(sunAngle); let sunOpacity = map(sin(sunAngle), 0, 1, 0, 255, true); if (sunOpacity > 0) { noStroke(); fill(255, 255, 0, sunOpacity); ellipse(sunX, sunY, 50, 50); } let moonTime = (t + 0.5) % 1.0; let moonAngle = map(moonTime, 0.25, 0.75, PI, 0); let moonX = width / 2 + (width/2 + 30) * cos(moonAngle); let moonY = height * 0.8 - (height * 0.7) * sin(moonAngle); let moonOpacity = map(sin(moonAngle), 0, 1, 0, 200, true); if (moonOpacity > 0) { noStroke(); fill(240, 240, 255, moonOpacity); ellipse(moonX, moonY, 40, 40); } }
      function drawStars(opacity) { if (opacity <= 0) return; push(); for(const star of stars) { let starOpacity = opacity * random(100, 255); stroke(255, 255, 255, starOpacity); strokeWeight(random(1, 2)); point(star.x, star.y); } pop(); }
      class Cloud { constructor(x, y, size, speed) { this.x = x; this.y = y; this.size = size; this.speed = speed; this.puffs = []; for (let i = 0; i < random(3, 6); i++) { this.puffs.push({ xOff: random(-this.size * 0.6, this.size * 0.6), yOff: random(-this.size * 0.2, this.size * 0.2), r: random(this.size * 0.5, this.size * 0.8) }); } } move() { this.x += this.speed; if (this.x > width + this.size) this.x = -this.size; } display(c) { noStroke(); fill(c); for (const puff of this.puffs) { ellipse(this.x + puff.xOff, this.y + puff.yOff, puff.r, puff.r * 0.7); } } }

      function windowResized() { resizeCanvas(windowWidth, windowHeight); }
      
    </script>
  </body>
</html>

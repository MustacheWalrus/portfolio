<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Sky with Bird Murmuration</title>
    
    <!-- Tailwind CSS for styling UI elements -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- TensorFlow.js and Body-Pix model for silhouette detection -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix"></script>
    
    <!-- p5.js for the main animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
        font-family: 'Inter', sans-serif;
      }
      /* This is the container for the entire experience within the modal */
      .project-content {
        width: 100%;
        /* 16:9 aspect ratio */
        aspect-ratio: 16 / 9;
        position: relative;
        background-color: #000;
        overflow: hidden;
        border-radius: 0.5rem; /* Match modal rounding */
      }
      /* Position the p5.js canvas to fill the container */
      #defaultCanvas0 {
        position: absolute;
        top: 0;
        left: 0;
        width: 100% !important;
        height: 100% !important;
        z-index: 1;
      }
      /* Container for all overlay content */
      #overlay-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between; /* Pushes text to top and hides webcam view */
        padding: 1rem;
        pointer-events: none; /* Allow clicks to pass through to p5 canvas */
      }
      /* Elements within the overlay should be clickable */
      #overlay-container > * {
          pointer-events: auto;
      }
      #silhouette-canvas {
        display: none; /* The silhouette canvas is not needed visually */
      }
      #webcam {
        display: none; /* The raw video feed is hidden */
      }
      .ui-text {
        transition: opacity 0.5s ease-in-out;
      }
    </style>
  </head>
  <body>
    <!-- Main container that will be embedded in the modal -->
    <div class="project-content">
        <!-- p5.js canvas will be placed here by the script -->

        <!-- Container for all UI and the silhouette canvas, layered on top of p5 -->
        <div id="overlay-container">
            <div class="ui-text w-full max-w-4xl text-center text-white">
                <h1 class="text-xl md:text-2xl font-bold mb-1">Interactive Sky</h1>
                <p class="text-gray-400 text-sm">Click canvas for fullscreen. Press 'R' to rotate. Press 'M' to mirror.</p>
            </div>

            <!-- This div holds the hidden video and canvas elements needed for BodyPix -->
            <div id="main-content" class="absolute -bottom-96">
                <video id="webcam" autoplay playsinline></video>
                <canvas id="silhouette-canvas"></canvas>
            </div>
            
            <div id="loading" class="absolute inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75 z-10">
                <div class="text-center text-white">
                    <p class="text-lg font-semibold">Loading AI Model...</p>
                    <p class="text-gray-400 text-sm">Please allow webcam access.</p>
                </div>
            </div>

            <div id="error-box" class="hidden absolute inset-0 flex items-center justify-center bg-red-900 bg-opacity-75 p-4 z-20">
                <p id="error-message" class="text-center font-semibold text-white"></p>
            </div>
        </div>
    </div>
    
    <div class="project-blurb">
      <p>This conservation piece symbolizes the repercussions and impact of our interactions with nature. The player can interact with the birds using their mirrored silhouette, but the flock will only fly normally without human intervention.</p>
    </div>

    <script>
      // =================================================================
      //  MERGED SCRIPT LOGIC
      // =================================================================
      let p5_instance;

      // Wrap p5 sketch in instance mode to avoid global conflicts
      const sketch = (p) => {
        // --- p5.js Animation Variables ---
        let farClouds = [], nearClouds = [], flock = [], stars = [];
        let cycleDuration = 3600, time = 0, colors;
        let obstacleCanvas; // Hidden canvas for birds to detect the silhouette

        // --- UI & Interaction Variables ---
        let rotationAngle = 0;
        let isMirrored = true; 
        let lastMotionTime = 0;
        let uiOpacity = 1.0;
        const FADE_DELAY = 10000; // 10 seconds in milliseconds
        let uiTextContainer;
        let previousSegmentationData = null; // Stores the last frame's silhouette data
        const MOTION_THRESHOLD = 500; // Increased threshold to reduce sensitivity
        let startTime = 0;
        let initialGracePeriodOver = false;

        p.setup = () => {
          let container = document.querySelector('.project-content');
          p.createCanvas(container.clientWidth, container.clientHeight).parent(container);
          
          obstacleCanvas = p.createGraphics(p.width, p.height);
          uiTextContainer = document.querySelector('.ui-text');
          startTime = p.millis(); // Record the start time for the grace period

          colors = {
              dawn: { top: p.color(24, 58, 114), bottom: p.color(240, 150, 114) },
              day: { top: p.color(135, 206, 250), bottom: p.color(240, 248, 255) },
              dusk: { top: p.color(24, 58, 114), bottom: p.color(218, 93, 76) },
              night: { top: p.color(1, 2, 20), bottom: p.color(14, 28, 64) }
          };

          for (let i = 0; i < 25; i++) farClouds.push(new Cloud(p.random(p.width), p.random(p.height * 0.6), p.random(60, 120), 0.3));
          for (let i = 0; i < 15; i++) nearClouds.push(new Cloud(p.random(p.width), p.random(p.height * 0.7), p.random(100, 220), 0.7));
          for (let i = 0; i < 200; i++) flock.push(new Boid());
          for (let i = 0; i < 300; i++) stars.push(p.createVector(p.random(p.width), p.random(p.height)));
        };

        p.draw = () => {
          time = (p.frameCount % cycleDuration) / cycleDuration;
          let sky = getSkyColors(time);
          
          for (let i = 0; i < p.height; i++) {
            let inter = p.map(i, 0, p.height, 0, 1);
            let c = p.lerpColor(sky.top, sky.bottom, inter);
            p.stroke(c);
            p.line(0, i, p.width, i);
          }

          let lightLevel = getLightLevel(time);
          drawStars(1 - lightLevel**2);
          drawSunAndMoon(time);

          let cloudColor = p.lerpColor(p.color(80, 80, 100, 180), p.color(255, 255, 255, 210), lightLevel);
          farClouds.forEach(c => { c.move(); c.display(cloudColor); });

          let boidColor = p.lerpColor(p.color(180, 180, 200, 150), p.color(40, 40, 40, 200), lightLevel);
          flock.forEach(boid => {
            boid.edges();
            boid.flock(flock);
            boid.update();
            boid.show(boidColor);
          });
          
          nearClouds.forEach(c => { c.move(); c.display(cloudColor); });

          if (obstacleCanvas && obstacleCanvas.width > 0 && obstacleCanvas.height > 0) {
              p.tint(255, 255 * 0.2);
              p.image(obstacleCanvas, 0, 0, p.width, p.height);
              p.noTint();
          }

          if (!initialGracePeriodOver) {
              uiOpacity = 1;
              if (p.millis() - startTime > FADE_DELAY) {
                  initialGracePeriodOver = true;
                  lastMotionTime = p.millis();
              }
          } else {
              const timeSinceMotion = p.millis() - lastMotionTime;
              if (timeSinceMotion > FADE_DELAY) {
                  uiOpacity = p.min(uiOpacity + 0.02, 1);
              } else {
                  uiOpacity = p.max(uiOpacity - 0.02, 0);
              }
          }
          if(uiTextContainer) uiTextContainer.style.opacity = uiOpacity;
        };
        
        // Make variables accessible to BodyPix script
        p.getObstacleCanvas = () => obstacleCanvas;
        p.getIsMirrored = () => isMirrored;
        p.getRotationAngle = () => rotationAngle;
        p.getCanvasDimensions = () => ({w: p.width, h: p.height});
        p.updateLastMotionTime = () => { lastMotionTime = p.millis(); };
        p.isGracePeriodOver = () => initialGracePeriodOver;

        class Boid {
          constructor() { this.position = p.createVector(p.random(p.width), p.random(p.height)); this.velocity = p5.Vector.random2D(); this.velocity.setMag(p.random(2, 4)); this.acceleration = p.createVector(); this.maxForce = 0.3; this.maxSpeed = 5; }
          avoid(obstacles) { if (this.isObstacle(this.position, obstacles)) { let escapeTarget = this.findNearestExit(obstacles); if (escapeTarget) { let desired = p5.Vector.sub(escapeTarget, this.position); desired.setMag(this.maxSpeed * 2); let steer = p5.Vector.sub(desired, this.velocity); steer.limit(this.maxForce * 5); return steer; } } else { let steer = p.createVector(); let feelerLength = 40; let ahead = this.velocity.copy().setMag(feelerLength); let pointAhead = p5.Vector.add(this.position, ahead); let aheadLeft = ahead.copy().rotate(-p.PI / 4); let pointLeft = p5.Vector.add(this.position, aheadLeft); let aheadRight = ahead.copy().rotate(p.PI / 4); let pointRight = p5.Vector.add(this.position, aheadRight); if (this.isObstacle(pointAhead, obstacles)) { let force = p5.Vector.sub(pointAhead, this.position).mult(-1); steer.add(force); } if (this.isObstacle(pointLeft, obstacles)) { let force = p5.Vector.sub(pointLeft, this.position).mult(-1); steer.add(force); } if (this.isObstacle(pointRight, obstacles)) { let force = p5.Vector.sub(pointRight, this.position).mult(-1); steer.add(force); } if (steer.mag() > 0) { steer.setMag(this.maxSpeed); steer.sub(this.velocity); steer.limit(this.maxForce * 3); } return steer; } return p.createVector(0, 0); }
          findNearestExit(obstacles) { for (let r = 10; r < 200; r += 10) { for (let a = 0; a < p.TWO_PI; a += p.PI / 8) { let checkX = this.position.x + r * p.cos(a); let checkY = this.position.y + r * p.sin(a); if (!this.isObstacle(p.createVector(checkX, checkY), obstacles)) { return p.createVector(checkX, checkY); } } } return null; }
          isObstacle(point, obstacles) { if (point.x > 0 && point.x < p.width && point.y > 0 && point.y < p.height) { let c = obstacles.get(p.floor(point.x), p.floor(point.y)); return c[3] > 10; } return false; }
          flock(boids) { let alignment = this.align(boids); let cohesion = this.cohesion(boids); let separation = this.separation(boids); let avoidance = this.avoid(obstacleCanvas); avoidance.mult(5.0); separation.mult(2.0); alignment.mult(1.0); cohesion.mult(1.0); this.acceleration.add(avoidance); this.acceleration.add(separation); this.acceleration.add(alignment); this.acceleration.add(cohesion); }
          edges() { if (this.position.x > p.width) this.position.x = 0; else if (this.position.x < 0) this.position.x = p.width; if (this.position.y > p.height) this.position.y = 0; else if (this.position.y < 0) this.position.y = p.height; }
          align(boids) { let perceptionRadius = 50; let steering = p.createVector(); let total = 0; for (let other of boids) { let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y); if (other != this && d < perceptionRadius) { steering.add(other.velocity); total++; } } if (total > 0) { steering.div(total); steering.setMag(this.maxSpeed); steering.sub(this.velocity); steering.limit(this.maxForce); } return steering; }
          separation(boids) { let perceptionRadius = 40; let steering = p.createVector(); let total = 0; for (let other of boids) { let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y); if (other != this && d < perceptionRadius) { let diff = p5.Vector.sub(this.position, other.position); diff.div(d * d); steering.add(diff); total++; } } if (total > 0) { steering.div(total); steering.setMag(this.maxSpeed); steering.sub(this.velocity); steering.limit(this.maxForce); } return steering; }
          cohesion(boids) { let perceptionRadius = 60; let steering = p.createVector(); let total = 0; for (let other of boids) { let d = p.dist(this.position.x, this.position.y, other.position.x, other.position.y); if (other != this && d < perceptionRadius) { steering.add(other.position); total++; } } if (total > 0) { steering.div(total); steering.sub(this.position); steering.setMag(this.maxSpeed); steering.sub(this.velocity); steering.limit(this.maxForce); } return steering; }
          update() { this.position.add(this.velocity); this.velocity.add(this.acceleration); this.velocity.limit(this.maxSpeed); this.acceleration.mult(0); }
          show(c) { let theta = this.velocity.heading() + p.PI / 2; p.fill(c); p.stroke(p.lerpColor(c, p.color(0), 0.5)); p.strokeWeight(1); p.push(); p.translate(this.position.x, this.position.y); p.rotate(theta); p.beginShape(); p.vertex(0, -6); p.vertex(-3, 6); p.vertex(3, 6); p.endShape(p.CLOSE); p.pop(); }
        }

        function getSkyColors(t) { if (t < 0.25) { return { top: p.lerpColor(colors.night.top, colors.dawn.top, p.map(t, 0, 0.25, 0, 1)), bottom: p.lerpColor(colors.night.bottom, colors.dawn.bottom, p.map(t, 0, 0.25, 0, 1)) }; } else if (t < 0.5) { return { top: p.lerpColor(colors.dawn.top, colors.day.top, p.map(t, 0.25, 0.5, 0, 1)), bottom: p.lerpColor(colors.dawn.bottom, colors.day.bottom, p.map(t, 0.25, 0.5, 0, 1)) }; } else if (t < 0.75) { return { top: p.lerpColor(colors.day.top, colors.dusk.top, p.map(t, 0.5, 0.75, 0, 1)), bottom: p.lerpColor(colors.day.bottom, colors.dusk.bottom, p.map(t, 0.5, 0.75, 0, 1)) }; } else { return { top: p.lerpColor(colors.dusk.top, colors.night.top, p.map(t, 0.75, 1, 0, 1)), bottom: p.lerpColor(colors.dusk.bottom, colors.night.bottom, p.map(t, 0.75, 1, 0, 1)) }; } }
        function getLightLevel(t) { let angle = p.map(t, 0, 1, 0, p.TWO_PI); return (-p.cos(angle) + 1) / 2; }
        function drawSunAndMoon(t) { let sunAngle = p.map(t, 0.25, 0.75, p.PI, 0); let sunX = p.width / 2 + (p.width/2 + 80) * p.cos(sunAngle); let sunY = p.height * 0.8 - (p.height * 0.7) * p.sin(sunAngle); let sunOpacity = p.map(p.sin(sunAngle), 0, 1, 0, 255, true); if (sunOpacity > 0) { p.noStroke(); p.fill(255, 255, 200, sunOpacity / 2); p.ellipse(sunX, sunY, 120, 120); p.fill(255, 255, 0, sunOpacity); p.ellipse(sunX, sunY, 80, 80); } let moonTime = (t + 0.5) % 1.0; let moonAngle = p.map(moonTime, 0.25, 0.75, p.PI, 0); let moonX = p.width / 2 + (p.width/2 + 60) * p.cos(moonAngle); let moonY = p.height * 0.8 - (p.height * 0.7) * p.sin(moonAngle); let moonOpacity = p.map(p.sin(moonAngle), 0, 1, 0, 200, true); if (moonOpacity > 0) { p.noStroke(); p.fill(240, 240, 255, moonOpacity); p.ellipse(moonX, moonY, 60, 60); } }
        function drawStars(opacity) { if (opacity <= 0) return; p.push(); for(const star of stars) { let starOpacity = opacity * p.random(100, 255); p.stroke(255, 255, 255, starOpacity); p.strokeWeight(p.random(1, 3)); p.point(star.x, star.y); } p.pop(); }
        class Cloud { constructor(x, y, size, speed) { this.x = x; this.y = y; this.size = size; this.speed = speed; this.puffs = []; for (let i = 0; i < p.random(5, 10); i++) { this.puffs.push({ xOff: p.random(-this.size * 0.6, this.size * 0.6), yOff: p.random(-this.size * 0.2, this.size * 0.2), r: p.random(this.size * 0.5, this.size * 0.8) }); } } move() { this.x += this.speed; if (this.x > p.width + this.size) this.x = -this.size; } display(c) { p.noStroke(); p.fill(c); for (const puff of this.puffs) { p.ellipse(this.x + puff.xOff, this.y + puff.yOff, puff.r, puff.r * 0.7); } } }

        p.windowResized = () => { let container = document.querySelector('.project-content'); p.resizeCanvas(container.clientWidth, container.clientHeight); if(obstacleCanvas) obstacleCanvas.resizeCanvas(p.width, p.height); }
        p.mousePressed = () => { if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) { try { let fs = p.fullscreen(); p.fullscreen(!fs); } catch (e) {} } }
        p.keyTyped = () => { if (p.key === 'm' || p.key === 'M') { isMirrored = !isMirrored; } if (p.key === 'r' || p.key === 'R') { rotationAngle = (rotationAngle + 90) % 360; } }
      };


      // --- Body-Pix Silhouette Functions ---
      const videoElement = document.getElementById('webcam');
      const silhouetteCanvasElement = document.getElementById('silhouette-canvas');
      const loadingElement = document.getElementById('loading');
      const errorBoxElement = document.getElementById('error-box');
      const errorMessageElement = document.getElementById('error-message');
      const VIDEO_WIDTH = 640;
      const VIDEO_HEIGHT = 480;
      let previousSegmentationData_bodypix = null;

      function showError(message) { errorMessageElement.textContent = message; errorBoxElement.classList.remove('hidden'); loadingElement.classList.add('hidden'); }
      async function setupCamera() { try { const stream = await navigator.mediaDevices.getUserMedia({ video: { width: VIDEO_WIDTH, height: VIDEO_HEIGHT }, audio: false, }); videoElement.srcObject = stream; return new Promise((resolve) => { videoElement.onloadedmetadata = () => { videoElement.width = videoElement.videoWidth; videoElement.height = videoElement.videoHeight; silhouetteCanvasElement.width = videoElement.videoWidth; silhouetteCanvasElement.height = videoElement.videoHeight; resolve(); }; }); } catch (error) { showError("Could not access webcam. Please check permissions."); throw error; } }
      
      async function detectSilhouette(model) {
        if (!p5_instance) return;
        try {
            const segmentation = await model.segmentPerson(videoElement, { flipHorizontal: false, internalResolution: 'medium', segmentationThreshold: 0.5 });
            const foregroundColor = { r: 128, g: 0, b: 128, a: 255 };
            const backgroundColor = { r: 0, g: 0, b: 0, a: 0 };
            const coloredPartImage = bodyPix.toMask(segmentation, foregroundColor, backgroundColor);
            
            if (coloredPartImage) {
                if (p5_instance.isGracePeriodOver()) {
                    if (previousSegmentationData_bodypix) {
                        let changedPixels = 0;
                        for (let i = 0; i < coloredPartImage.data.length; i += 4 * 10) {
                            if (coloredPartImage.data[i + 3] !== previousSegmentationData_bodypix[i + 3]) {
                                changedPixels++;
                            }
                        }
                        if (changedPixels > 500) {
                            p5_instance.updateLastMotionTime();
                        }
                    } else {
                        p5_instance.updateLastMotionTime();
                    }
                }
                previousSegmentationData_bodypix = coloredPartImage.data;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = coloredPartImage.width;
                tempCanvas.height = coloredPartImage.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(coloredPartImage, 0, 0);

                const obstacleCanvas = p5_instance.getObstacleCanvas();
                const obsCtx = obstacleCanvas.drawingContext;
                const {w, h} = p5_instance.getCanvasDimensions();
                const isMirrored = p5_instance.getIsMirrored();
                const rotationAngle = p5_instance.getRotationAngle();
                
                obstacleCanvas.clear();
                obsCtx.save();
                obsCtx.translate(w / 2, h / 2);
                
                if(isMirrored) obsCtx.scale(-1, 1);
                obsCtx.rotate(rotationAngle * Math.PI / 180);
                
                const canvasAspect = (rotationAngle % 180 === 0) ? w / h : h / w;
                const imgAspect = tempCanvas.width / tempCanvas.height;
                
                let drawWidth, drawHeight;
                if (imgAspect > canvasAspect) {
                    drawHeight = (rotationAngle % 180 === 0) ? h : w;
                    drawWidth = drawHeight * imgAspect;
                } else {
                    drawWidth = (rotationAngle % 180 === 0) ? w : h;
                    drawHeight = drawWidth / imgAspect;
                }
                
                obsCtx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                obsCtx.restore();
            }
        } catch(error) {
            console.warn("Skipping a frame due to segmentation error.");
        }
      }

      async function initializeApp() {
        try {
            await setupCamera();
            const model = await bodyPix.load({ architecture: 'MobileNetV1', outputStride: 16, multiplier: 0.75, quantBytes: 2 });
            loadingElement.classList.add('hidden');
            // Start the p5.js sketch now that the camera is ready
            p5_instance = new p5(sketch);
            setInterval(() => detectSilhouette(model), 66);
        } catch (error) {
            if (!errorBoxElement.classList.contains('hidden')) {
               showError("Failed to load AI model. Please check connection or try another browser.");
            }
        }
      }

      initializeApp();
    </script>
  </body>
</html>

